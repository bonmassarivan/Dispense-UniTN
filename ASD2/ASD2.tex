\documentclass[oneside]{book}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{color}
\usepackage{algorithm}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usetikzlibrary{matrix}
\usepackage{setspace}

\title {Dispensa ASD 2}
\author{Bonmassar Ivan}

\begin{document}

\maketitle
\tableofcontents


\chapter{Programmazione dinamica}
\section{Hateville}

Ad Hateville viene organizzata una sagra. Per la raccolta fondi la casa i donera' n soldi solo se non doneranno entrambi i suoi vicini i-1 e i+1. Scrivere un algoritmo che restituisca il numero maggiore di soldi.
\begin{algorithmic}
\begin{algorithm}
\caption{Hateville(int[] DP, int n)}\label{alg:cap}

\State int [] D = new int[0...n]
\State DP[0] = 0;
\State DP[1] = D[1];
\For (i=2 to n)
	\State DP[i] = max(DP[i-2] + D[i], DP[i-1])
\EndFor

\end{algorithm}
\end{algorithmic}
Questo ritornera' una tabella DP dalla quale dovrebbe essere ricavabile la soluzione.

\newpage
\section{Knapsack}
Dato un insieme di oggetti con peso e con un loro valore e data una capacita' C di uno zaino, si calcoli il valore massimo trasportabile dallo zaino.

\begin{algorithm}
\caption{Knapsack(int[] w, int[] p, int C, int n)}\label{alg:cap}
\begin{algorithmic}
\State 	DP = new int[0...n][0...C];
\For {i = 0 to n} 
	\State DP[i][0] = 0;
\EndFor
\For {c = 0 to C}
\State DP[0][c] = 0;
\EndFor

\For {i=1 to n}
	\For{c=1 to C}
		\If{w[i] $\leq$ c}
			\State DP[i][c] = max(DP[i-1][c-w[i]] + p[i], DP[i-1][c]);
		
		\Else 	
			\State DP[i][c] = DP[i-1][c];	
		\EndIf
		
	\EndFor
\EndFor	

\end{algorithmic}
\end{algorithm}

This should return the correct matrix containing the solution in the bottom right corner.

C'e' anche una versione ricorsiva dello zaino con la memoization. La memoization e' l'approccio top-down, in pratica si controlla prima se quel problema e' gia stato risolto. DP e' inizializzata nella funzione wrapper con tutti gli elementi posti a -1.

\begin{algorithm}
\caption{Knapsack(int[] w, int[] p, int C, int n)}\label{alg:cap}
\begin{algorithmic}
\If {c $<$ 0}
	\State return -$\infty$ 
\ElsIf{i == 0 or c == 0}
	\State return 0
\Else
	\State \If{DP[i][c] $<$ 0 }
			\State int notTaken = knapsackRec(w,p,i-1,c,DP);
			\State int taken = knapsackRec(w,p, i-1,c-w[i],DP) + p[i];
			\State return max(taken,notTaken);
		\EndIf
	\EndIf
	\State return DP[i][c];

\end{algorithmic}
\end{algorithm}

La versione dello zaino senza fondo presenta invece un array DP e non una matrice. Lo si puo' trovare nelle slide di Montresor.


\section{Sottosequenza comune massimale}
Per SCM (d'ora in avanti LCS per longest common subsequence) s'intende la sottosequenza piu' lunga che due parole hanno in comune. Per esempio\\
AAAATTGA e AAATA, LCS coincide con AAATA, in quanto la sottosequenza non deve essere di fila.

\begin{algorithm}
\caption{int LCS(ITEM[] T, ITEM[] U, int n, int m)}\label{alg:cap}
\begin{algorithmic}
\State int[][] DP = new int[1...n][1...m];
\For{i = 0 to n}
	\State DP[i][0] = 0;
\EndFor
\For{j = 0 to m}
	\State DP[0][m] = 0;
\EndFor
\For{i=1 to n}
	\For{j=1 to m}
		\If {T[i] == U[i]}
			DP[i][j] = DP[i][j]+1;
			\Else
				\State DP[i][j] = max(DP[i-1][j],DP[i][j-1];
		\EndIf
	\EndFor
\EndFor

return DP[n][m];
\end{algorithmic}
\end{algorithm}

In pratica quello che viene fatto e' calcolare la LCS e nel caso la lettera preas in considerazione non sia uguale si controlla togliendo una lettera dalla prima parola e poi dalla seconda. Da notare che questo non da la soluzione, in quanto da solo la lunghezza massima della LCS.

\newpage

\section{String matching approssimativo}
Calcolare il minor numero k necessario per un pattern per essere trovato in una stringa. Le operazioni possibili sono, cancellazione, sostituzione e inserimento. Esempio:\\
BAB e' in ABABAB con k=0 modifiche. \\
unesempio e' contenuto in questoeunoscempio con k = 2 modifiche.

\begin{algorithm}
\caption{stringMatching()}\label{alg:cap}
\begin{algorithmic}
\State int [][] DP = new int [0...n][0...m] ;
\For{j = 0 to n} DP[0][j] = 0;
\EndFor

\For {i = 0 to m} DP[i][0] = i;
\EndFor

\For{i = 0 to m}
	\For {j = 0 to n}
		\State DP[i][j] =min( \State DP[i-1][j-1] + iff(P[i] == T[i], 0,1),
	\State        DP[i-1][j]+1,
	\State        DP[i][j-1])
	\EndFor

\EndFor
\end{algorithmic}
\end{algorithm}
\newpage
\section{Insieme di intervalli pesati}
Questo problema puo' essere spiegato con una sala riunioni e un'organizzazione degli appuntamenti che massimizza i profitti.

Per risolverlo, l'algoritmo fa uso di "predecessori" ovvero dell'intervallo di tempo appena prima quello selezionato.

\begin{algorithm}
\caption{Set maxSet(int[] a, int[] b, int[]w, int n)\label{alg:cap}}
\begin{algorithmic}
\State {ordina gli intervalli per estremi di fine crescenti}

\State int[] pred = computePred(a,b,n);
\State int[] DP = new int[0...n];
\State DP[0] = 0;
\For {i = 1 to n}
	\item DP[i] = max(DP[i-1], w[i]+DP[pred[i]]);
\EndFor

\State i = n;
\State Set s = Set();


\While{i $>$ 0}
	\If {DP[i-1] $>$ w[i]+DP[pred[i]]}
		\State i = i-1
	\Else
		S.insert(i)
		i = pred[i]
	\EndIf
\EndWhile

\end{algorithmic}
\end{algorithm}

\chapter{Greedy}
\section{Insieme di intervalli}
Nella versione greedy del problema non sono piu' pesati. Per greedy si intende una "tattica" da utilizzare per scegliere la soluzione migliore senza dover calcolare le altre. In questo caso la scelta migliore e' quella di scegliere gli intervalli man mano con il minor tempo di fine. 


\begin{algorithm}
\caption{Set indipendentSet(int[] a, int[] b)\label{alg:cap}}
\begin{algorithmic}
\State {ordina a e b in modo che b[1] $<$ b[2]... }
Set S = Set();
S.insert(1)
int last = 1
\For {i = 2 to n}
	\If
		{a[i] $\geq $ b[last]}
		\State S.insert(i)
		\State last = i;
	\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}
\newpage
\section{Compressione di Huffman}
La compressione di caratteri di Huffman si basa sull'idea di creare una codifica per ogni file. Questo per fare in modo che ogni file abbia una sua specifica e corretta frequenza dei caratteri. I caratteri con minor frequenza avranno prefissi piu' lunghi.

\begin{algorithm}
\caption{huffman(int[]c,int[]f, int n)\label{alg:cap}}
\begin{algorithmic}
\State PriorityQueue Q = minPriorityQueue();
\For	{i = 1 to n}
	\State Q.insert(f[i],c[i]);
\EndFor
\For{i=1 to n-1}
	\State $z_1$ = Q.deleteMin();
	\State $z_2$ = Q.deleteMin();
	\State z = Tree($z_1$.f+$z_2$.f, nil);	
	\State z.left = $z_1$;
	\State z.right = $z_2$;
	\State Q.insert(z.f,z);
\EndFor
\end{algorithmic}
\end{algorithm}

\newpage
\section{Albero di copertura minimo}
Questo problema viene risolto da due algoritmi. 

L'idea del primo (Kruskal) e' quella di ingrandire sottoinsiemi disgiunti di un albero, connettendoli tra loro fino ad avere l'albero complessivo.

\begin{algorithm}
\caption{Kruskal(Edge[]A, int n, int m)\label{alg:cap}}

\begin{algorithmic}
\State Set T = Set();
\State MFSET M = Mfset(n);
\State {ordina A in ordine crescente di pesi};
\State int count = 0;
\State int i = 1;
\While{count $<$ n-1 and i $\leq$ m}
	\If{M.find(A[i].u $\neq$ M.find(A[i].v}
	\State M.merge(A[i].u,A[i].v)
	\State T.insert(A[i])
	\State count++
	\EndIf
	\State i++
\EndWhile

\end{algorithmic}
\end{algorithm}

\chapter{Esami vecchi}
\section{Octals}
Scrivere un algoritmo che stampa tutti gli ottali (numeri da 0 a 7) con n cifre.

Viene riportato solamente la funzione ricorsiva. Il wrapper inizializzava l'array S soluzione e chiamava la funzione con i seguenti valori: S,n,-1

\begin{algorithm}
\caption{octalsRec(int n)\label{alg:cap}}
\begin{algorithmic}
\If{i==0}
	\State print S
\Else
	\For{d==0 to 7}
		\If{d $\neq$ prev}
			\State S[i] = d;
			\State octalsRec(S,i-1,d);
		\EndIf
	\EndFor
\EndIf

\end{algorithmic}
\end{algorithm}
\end{document}
\documentclass[oneside]{book}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{color}
\usepackage{algorithm}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usetikzlibrary{matrix}
\usepackage{setspace}
\usepackage{amsmath}

\title {Dispensa ASD 2}
\author{Bonmassar Ivan}

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\begin{document}

\maketitle
\tableofcontents


\chapter{Programmazione dinamica}
\section{Hateville}

Ad Hateville viene organizzata una sagra. Per la raccolta fondi la casa i donera' n soldi solo se non doneranno entrambi i suoi vicini i-1 e i+1. Scrivere un algoritmo che restituisca il numero maggiore di soldi.
\begin{algorithmic}
\begin{algorithm}
\caption{Hateville(int[] DP, int n)}\label{alg:cap}

\State int [] D = new int[0...n]
\State DP[0] = 0;
\State DP[1] = D[1];
\For (i=2 to n)
	\State DP[i] = max(DP[i-2] + D[i], DP[i-1])
\EndFor

\end{algorithm}
\end{algorithmic}
Questo ritornera' una tabella DP dalla quale dovrebbe essere ricavabile la soluzione.

\newpage
\section{Knapsack}
Dato un insieme di oggetti con peso e con un loro valore e data una capacita' C di uno zaino, si calcoli il valore massimo trasportabile dallo zaino.

\begin{algorithm}
\caption{Knapsack(int[] w, int[] p, int C, int n)}\label{alg:cap}
\begin{algorithmic}
\State 	DP = new int[0...n][0...C];
\For {i = 0 to n} 
	\State DP[i][0] = 0;
\EndFor
\For {c = 0 to C}
\State DP[0][c] = 0;
\EndFor

\For {i=1 to n}
	\For{c=1 to C}
		\If{w[i] $\leq$ c}
			\State DP[i][c] = max(DP[i-1][c-w[i]] + p[i], DP[i-1][c]);
		
		\Else 	
			\State DP[i][c] = DP[i-1][c];	
		\EndIf
		
	\EndFor
\EndFor	

\end{algorithmic}
\end{algorithm}

This should return the correct matrix containing the solution in the bottom right corner.

C'e' anche una versione ricorsiva dello zaino con la memoization. La memoization e' l'approccio top-down, in pratica si controlla prima se quel problema e' gia stato risolto. DP e' inizializzata nella funzione wrapper con tutti gli elementi posti a -1.

\begin{algorithm}
\caption{Knapsack(int[] w, int[] p, int C, int n)}\label{alg:cap}
\begin{algorithmic}
\If {c $<$ 0}
	\State return -$\infty$ 
\ElsIf{i == 0 or c == 0}
	\State return 0
\Else
	\State \If{DP[i][c] $<$ 0 }
			\State int notTaken = knapsackRec(w,p,i-1,c,DP);
			\State int taken = knapsackRec(w,p, i-1,c-w[i],DP) + p[i];
			\State return max(taken,notTaken);
		\EndIf
	\EndIf
	\State return DP[i][c];

\end{algorithmic}
\end{algorithm}

La versione dello zaino senza fondo presenta invece un array DP e non una matrice. Lo si puo' trovare nelle slide di Montresor.


\section{Sottosequenza comune massimale}
Per SCM (d'ora in avanti LCS per longest common subsequence) s'intende la sottosequenza piu' lunga che due parole hanno in comune. Per esempio\\
AAAATTGA e AAATA, LCS coincide con AAATA, in quanto la sottosequenza non deve essere di fila.

\begin{algorithm}
\caption{int LCS(ITEM[] T, ITEM[] U, int n, int m)}\label{alg:cap}
\begin{algorithmic}
\State int[][] DP = new int[1...n][1...m];
\For{i = 0 to n}
	\State DP[i][0] = 0;
\EndFor
\For{j = 0 to m}
	\State DP[0][m] = 0;
\EndFor
\For{i=1 to n}
	\For{j=1 to m}
		\If {T[i] == U[i]}
			DP[i][j] = DP[i][j]+1;
			\Else
				\State DP[i][j] = max(DP[i-1][j],DP[i][j-1];
		\EndIf
	\EndFor
\EndFor

return DP[n][m];
\end{algorithmic}
\end{algorithm}

In pratica quello che viene fatto e' calcolare la LCS e nel caso la lettera preas in considerazione non sia uguale si controlla togliendo una lettera dalla prima parola e poi dalla seconda. Da notare che questo non da la soluzione, in quanto da solo la lunghezza massima della LCS.

\newpage

\section{String matching approssimativo}
Calcolare il minor numero k necessario per un pattern per essere trovato in una stringa. Le operazioni possibili sono, cancellazione, sostituzione e inserimento. Esempio:\\
BAB e' in ABABAB con k=0 modifiche. \\
unesempio e' contenuto in questoeunoscempio con k = 2 modifiche.

\begin{algorithm}
\caption{stringMatching()}\label{alg:cap}
\begin{algorithmic}
\State int [][] DP = new int [0...n][0...m] ;
\For{j = 0 to n} DP[0][j] = 0;
\EndFor

\For {i = 0 to m} DP[i][0] = i;
\EndFor

\For{i = 0 to m}
	\For {j = 0 to n}
		\State DP[i][j] =min( \State DP[i-1][j-1] + iff(P[i] == T[i], 0,1),
	\State        DP[i-1][j]+1,
	\State        DP[i][j-1])
	\EndFor

\EndFor
\end{algorithmic}
\end{algorithm}
\newpage
\section{Insieme di intervalli pesati}
Questo problema puo' essere spiegato con una sala riunioni e un'organizzazione degli appuntamenti che massimizza i profitti.

Per risolverlo, l'algoritmo fa uso di "predecessori" ovvero dell'intervallo di tempo appena prima quello selezionato.

\begin{algorithm}
\caption{Set maxSet(int[] a, int[] b, int[]w, int n)\label{alg:cap}}
\begin{algorithmic}
\State {ordina gli intervalli per estremi di fine crescenti}

\State int[] pred = computePred(a,b,n);
\State int[] DP = new int[0...n];
\State DP[0] = 0;
\For {i = 1 to n}
	\item DP[i] = max(DP[i-1], w[i]+DP[pred[i]]);
\EndFor

\State i = n;
\State Set s = Set();


\While{i $>$ 0}
	\If {DP[i-1] $>$ w[i]+DP[pred[i]]}
		\State i = i-1
	\Else
		S.insert(i)
		i = pred[i]
	\EndIf
\EndWhile

\end{algorithmic}
\end{algorithm}

\chapter{Greedy}
\section{Insieme di intervalli}
Nella versione greedy del problema non sono piu' pesati. Per greedy si intende una "tattica" da utilizzare per scegliere la soluzione migliore senza dover calcolare le altre. In questo caso la scelta migliore e' quella di scegliere gli intervalli man mano con il minor tempo di fine. 


\begin{algorithm}
\caption{Set indipendentSet(int[] a, int[] b)\label{alg:cap}}
\begin{algorithmic}
\State {ordina a e b in modo che b[1] $<$ b[2]... }
Set S = Set();
S.insert(1)
int last = 1
\For {i = 2 to n}
	\If
		{a[i] $\geq $ b[last]}
		\State S.insert(i)
		\State last = i;
	\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}
\newpage
\section{Compressione di Huffman}
La compressione di caratteri di Huffman si basa sull'idea di creare una codifica per ogni file. Questo per fare in modo che ogni file abbia una sua specifica e corretta frequenza dei caratteri. I caratteri con minor frequenza avranno prefissi piu' lunghi.

\begin{algorithm}
\caption{huffman(int[]c,int[]f, int n)\label{alg:cap}}
\begin{algorithmic}
\State PriorityQueue Q = minPriorityQueue();
\For	{i = 1 to n}
	\State Q.insert(f[i],c[i]);
\EndFor
\For{i=1 to n-1}
	\State $z_1$ = Q.deleteMin();
	\State $z_2$ = Q.deleteMin();
	\State z = Tree($z_1$.f+$z_2$.f, nil);	
	\State z.left = $z_1$;
	\State z.right = $z_2$;
	\State Q.insert(z.f,z);
\EndFor
\end{algorithmic}
\end{algorithm}

\newpage
\section{Albero di copertura minimo}
Questo problema viene risolto da due algoritmi. 

L'idea del primo (Kruskal) e' quella di ingrandire sottoinsiemi disgiunti di un albero, connettendoli tra loro fino ad avere l'albero complessivo.

\begin{algorithm}
\caption{Kruskal(Edge[]A, int n, int m)\label{alg:cap}}

\begin{algorithmic}
\State Set T = Set();
\State MFSET M = Mfset(n);
\State {ordina A in ordine crescente di pesi};
\State int count = 0;
\State int i = 1;
\While{count $<$ n-1 and i $\leq$ m}
	\If{M.find(A[i].u $\neq$ M.find(A[i].v}
	\State M.merge(A[i].u,A[i].v)
	\State T.insert(A[i])
	\State count++
	\EndIf
	\State i++
\EndWhile

\end{algorithmic}
\end{algorithm}



\chapter{Programmazione dinamica - esami}
\section{Sequenza k-contigua massimale}
Una sequenza k-contigua e' una sottosequenza che deriva dalla cancellazione di al piu' k elementi consecutivi dalla sequenza originale.

Esempio: 

k=1
A[1,2,3,4,5,6] => $A_c$[1,3,5] 

Scrivere un algoritmo che trova quella massimale.

\begin{algorithm}
\caption{kContigua(int[]v, int n, int k)\label{cap:alg}}
\begin{algorithmic}
\State int[][] DP = -1;
\State return kContiguaRec(V,n,k,DP)
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{kContiguaRec(int[]v, int i, int j,int[][] DP)\label{cap:alg}}
\begin{algorithmic}
\If{i $\leq$ 0}
	\State return 0
\EndIf
\If{DP[i][j] $<$ 0 }
	\If{j==0}
		\State DP[i][j] = kContiguaRec(V,i,j-1,DP) + V[i]
	\Else
		\State DP[i][j] = max(kContiguaRec(V,i-1,j-1,DP),kContiguaRec(V,i-1, j, DP)+V[i])
	\EndIf
\EndIf		
return DP[i][j]
\end{algorithmic}
\end{algorithm}

\section{Max Sum Increasing}
Scrivere un algoritmo che prenda in input un array di numeri e che calcoli il valore massimo della somma tra i numeri crescenti. Esempio:\\
A=[2, 102, 3, 4, 101, 5, 6] => 2+3+4+101 = 110;

L'idea e' la seguente:

\begin{equation}
  DP =
    \begin{cases}
      A[i] & \forall j, 1 \leq j \leq i : A[i] \leq A[j]\\
      max{DP[j]: 1 \leq j \leq i-1 \land A[j] < A[i]}+A[i] & otherwise      
    \end{cases}       
\end{equation}
\begin{algorithm}
\caption{maxSumIncreasing(int[] A, int n)\label{alg:cap}}
\begin{algorithmic}
\State int[] DP = new int[1..n]
\For{i = 1 to n}
	\State DP[i] = A[i]
	\For{j = 1 to i-1}
		\If{A[j] $<$ A[i] and DP[j] + A[i] $>$ DP[i]}
			\State DP[i] = DP[j]+A[i];
		\EndIf
	\EndFor

\EndFor
\end{algorithmic}
\end{algorithm}
\newpage
\section{Small sum}
Trovare il sottoinsieme con meno elementi per riempire uno zaino di capacita' C, dati un vettore di pesi W di dimensione n

L'idea e' la seguente:

\begin{equation}
DP = 
	\begin{cases}
		\infty & c < 0 \\
		\infty & i = 0\\
		0 & c = 0 \\
		min(DP[i-1][c],DP[i-1][c-W[i]]+1) & c > 0 \land i > 0
	\end{cases}
\end{equation}

\begin{algorithm}
\caption{ssRec(int[][] DP, int c, int[]W, int i)\label{alg:cap}}
\begin{algorithmic}
\If{c $<$ 0 }
	\State return $\infty$
\ElsIf{i = 0}
	\State return $\infty$

\ElsIf{c = 0}
	\State return 0

\Else
	\If{DP[i][c] $>$ 0}
		\State DP[i][c] = min(ssRec(DP, c, W, i-1), ssRec(DP, c-W[i], W,i-1)+1)
	\EndIf
\EndIf
\end{algorithmic}
\end{algorithm}
\chapter{Backtracking - esami}
\section{Octals}
Scrivere un algoritmo che stampa tutti gli ottali (numeri da 0 a 7) con n cifre.

Viene riportato solamente la funzione ricorsiva. Il wrapper inizializzava l'array S soluzione e chiamava la funzione con i seguenti valori: S,n,-1

\begin{algorithm}
\caption{octalsRec(int n)\label{alg:cap}}
\begin{algorithmic}
\If{i==0}
	\State print S
\Else
	\For{d==0 to 7}
		\If{d $\neq$ prev}
			\State S[i] = d;
			\State octalsRec(S,i-1,d);
		\EndIf
	\EndFor
\EndIf

\end{algorithmic}
\end{algorithm}

\newpage
\section{Binary}
Scrivere un algoritmo che prenda in input n, $n_0$ e $n_1$. Dovra' stampare le permutazioni di n cifre con massimo $n_0$ 0 consecutivi e massimo $n_1$ 1 consecutivi. 

Qui viene riportato soltanto la funzione ricorsiva. La funzione wrapper crea l'array S e poi chiama la funzione ricorsiva 
\begin{algorithm}
\caption{binaryRec(int[] S, int n, int $n_0$, int $n_1$, int $i_0$, int $_1$)}
\begin{algorithmic}
\If {n==0}
	\State print S
\EndIf
\If{$i_0 >$ 0}
	\State S[n] =0;
	\State binaryRec(S,n-1,$n_0$,$n_1$,$i_0$-1, $n_1$)
\EndIf
\If{$i_1 > $ 0 }
	\State S[n] =1;
	\State binaryRec(S,n-1, $n_0$, $i_1$-1,$i_1$)
\EndIf	
\end{algorithmic}
\end{algorithm}
\newpage
\section{Sequenza k-limitata}
Scrivere un algoritmo che prenda in input un vettore A[n] e un valore k e stampi tutte le sequenze k-limitate. Esempio: 

A = [4,6,3,1,4] e k = 1

le sottosequenze sono :\\
$[1][3][6][4][][4,3][4,3,4],[4,4] ...$

\begin{algorithm}
\caption{k-SequenzeRec(int[] A, Stack S, int i, int k)\label{alg:cap}}
\begin{algorithmic}

\If {i==0}
	\State print S
\Else
	\If {S.isEmpty() or $|$A[i] - S.top() $leq$ k$|$}
		\State S.push(A[i])
		\State k-SequenzeRec(A, S, i-1, k);
		\State S.pop()
	\EndIf
	\State k-SequenzeRec(A, S, i-1, k)

\EndIf
\end{algorithmic}
\end{algorithm}


\section{PrintBits}
Scrivere un algoritmo che stampi le sequenze di n bit senza 1 consecutivi.

\begin{algorithm}
\caption{printBitsRec(int[]S, int n, int i)\label{alg:cap}}
\begin{algorithmic}
\If{i == n+1}
	\State print S
\EndIf

\If{ i == 1 or S[i-1] $\neq$ 1}
	\State S[i] = 1
	\State printBitRec(S, n, i+1);
\Else
	\State S[i] = 0;
	\State printBitsRec(S,n,i+1);
\EndIf
\end{algorithmic}
\end{algorithm}
\newpage
\section{Primes}
Scrivere un algoritmo che prende in input un array P con i primi p numeri primi, un intero n e un intero k. Stampare tutte le somme di primi possibili per raggiungere n con esattamente k addendi. 

\begin{algorithm}
\caption{primesRec(int[] S, int[] P, int p, int n, int k)\label{alg:cap}}
\begin{algorithmic}
\If{k == 0 \textbf{and} n == 0}
	\State print S
\EndIf

\If{k $>$ 0 \textbf{and} n $>$ 0 \textbf{and} p $>$ 0   }
	\State primesRec(S,P,p-1,n,k)
	\State S[k] = P[p]
	\State primesRec($S,P,p-1,n-P[p],k-1$)
\EndIf
\end{algorithmic}
\end{algorithm}
\chapter{Misc - esami}

\section{Meeting point}
Scrivere un algoritmo che calcola il punto di incontro tra due nodi tale che questo sia a distanza uguale tra i due. Grafo pesato.

Basta utilizzare shortestPath visto nella prima parte e poi ciclare sui due array di risultato per vedere se ce n'e' uno uguale:

\begin{algorithm}
\caption{meetingPoint(Graph G, Node u, Node v)\label{cap:alg}}
\begin{algorithmic}
\State int[] $d_u$ = shortestPath(G,u);
\State int[] $d_v$ = shortestPath(G,v);
\ForEach{u in G}
	\If{$d_u$ == $d_v$ and $d_u \neq \infty$ }
		\State return true
	\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}
\end{document}
